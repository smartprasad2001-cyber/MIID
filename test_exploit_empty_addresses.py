"""
Test the address exploit by sending empty seed_addresses
This simulates the validator bug where seed_addresses is empty/None
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'MIID', 'validator'))

from unified_generator import process_full_synapse
from reward import get_name_variation_rewards
import numpy as np

# Simulate a validator synapse exactly as it sends to miner
# Format: List of [name, dob, address] arrays
identity_list = [
    ["Sebastian Martinez", "1990-05-15", "New York, USA"],
    ["Constantinople Alexandrov", "1985-03-22", "Moscow, Russia"],
    ["Xavier Rodriguez", "1992-11-08", "Madrid, Spain"],
    ["Theodore Williams", "1988-07-14", "London, UK"],
    ["Archimedes Johnson", "1995-01-30", "Chicago, USA"],
]

# Extract seed data
seed_names = [identity[0] for identity in identity_list]
seed_dob = [identity[1] for identity in identity_list]

# ⚠️ EXPLOIT TEST: Set seed_addresses to empty/None to trigger exploit
print("="*100)
print("TESTING ADDRESS EXPLOIT - EMPTY SEED ADDRESSES")
print("="*100)
print()
print("⚠️  Setting seed_addresses to [] to trigger exploit")
print("⚠️  Expected: Address Score = 1.0 (exploit works!)")
print()

# Test Case 1: Empty list
print("="*100)
print("TEST CASE 1: Empty list []")
print("="*100)
seed_addresses = []  # Empty list - should trigger exploit
seed_script = ["latin"] * len(seed_names)

# Query parameters
variation_count = 10
phonetic_similarity = {"Light": 0.2, "Medium": 0.6, "Far": 0.2}
orthographic_similarity = {"Light": 0.2, "Medium": 0.6, "Far": 0.2}
rule_based = None

# Process the synapse (simulate miner processing)
print("Processing synapse (miner simulation)...")
variations_dict = process_full_synapse(
    identity_list=identity_list,
    variation_count=variation_count,
    light_pct=phonetic_similarity["Light"],
    medium_pct=phonetic_similarity["Medium"],
    far_pct=phonetic_similarity["Far"],
    verbose=False
)

# Create response as validator expects
class MockResponse:
    def __init__(self, variations):
        self.variations = variations

class MockNeuron:
    burn_fraction = 0.40
    top_miner_cap = 10
    quality_threshold = 0.5
    decay_rate = 0.1
    blend_factor = 0.5

class MockConfig:
    def __init__(self):
        self.neuron = MockNeuron()

class MockValidator:
    def __init__(self):
        self.uid = 0
        self.config = MockConfig()
    
    def get_name_variation_rewards(self, seed_names, seed_dob, seed_addresses, seed_script, 
                                   responses, uids, variation_count, phonetic_similarity, 
                                   orthographic_similarity, rule_based):
        return get_name_variation_rewards(
            self, seed_names, seed_dob, seed_addresses, seed_script,
            responses, uids, variation_count, phonetic_similarity,
            orthographic_similarity, rule_based
        )

validator = MockValidator()
response = MockResponse(variations_dict)
responses = [response]
uids = [1]

print("Testing with rewards.py...")
print()

try:
    rewards, base_rewards, detailed_metrics = validator.get_name_variation_rewards(
        seed_names=seed_names,
        seed_dob=seed_dob,
        seed_addresses=seed_addresses,  # ← EMPTY LIST (exploit trigger!)
        seed_script=seed_script,
        responses=responses,
        uids=uids,
        variation_count=variation_count,
        phonetic_similarity=phonetic_similarity,
        orthographic_similarity=orthographic_similarity,
        rule_based=rule_based
    )
    
    if detailed_metrics:
        metrics = detailed_metrics[0]
        
        print("="*100)
        print("RESULTS - TEST CASE 1: Empty list []")
        print("="*100)
        print()
        
        # Address Score
        address_grading = metrics.get('address_grading', {})
        address_score = address_grading.get('overall_score', 0.0)
        
        print(f"Address Score: {address_score:.3f}")
        print()
        
        # Check what keys exist
        print("Address grading keys:", list(address_grading.keys()))
        print()
        
        # Address sub-scores
        heuristic_perfect = address_grading.get('heuristic_perfect')
        region_matches = address_grading.get('region_matches')
        api_result = address_grading.get('api_result')
        
        print(f"heuristic_perfect: {heuristic_perfect} (type: {type(heuristic_perfect)})")
        print(f"region_matches: {region_matches} (type: {type(region_matches)})")
        print(f"api_result: {api_result} (type: {type(api_result)})")
        print()
        
        # Display sub-scores
        address_looks_like = 1.0 if (heuristic_perfect is True) else 0.0
        address_region_match = 1.0 if (region_matches is not None and region_matches > 0) else 0.0
        address_api_call = 1.0 if (api_result == "SUCCESS") else 0.0
        
        print(f"Looks Like Address: {address_looks_like:.3f}")
        print(f"Address Regain Match: {address_region_match:.3f}")
        print(f"Address API call: {address_api_call:.3f}")
        print()
        
        # Check if exploit worked
        if address_score == 1.0 and heuristic_perfect is None:
            print("✅ EXPLOIT WORKED!")
            print("   - Address Score = 1.0")
            print("   - Sub-scores not set (function returned early)")
            print("   - This confirms the exploit is working!")
        elif address_score > 0.9:
            print("⚠️  EXPLOIT PARTIALLY WORKED")
            print(f"   - Address Score = {address_score:.3f} (close to 1.0)")
            print("   - May have been modified by penalty or rounding")
        else:
            print("❌ EXPLOIT DID NOT WORK")
            print(f"   - Address Score = {address_score:.3f}")
            print("   - Exploit check may have failed")
        
        print()
        
except Exception as e:
    print(f"❌ Error: {e}")
    import traceback
    traceback.print_exc()

# Test Case 2: All None
print()
print("="*100)
print("TEST CASE 2: All None [None, None, None, ...]")
print("="*100)
seed_addresses = [None] * len(seed_names)  # All None - should trigger exploit

try:
    rewards, base_rewards, detailed_metrics = validator.get_name_variation_rewards(
        seed_names=seed_names,
        seed_dob=seed_dob,
        seed_addresses=seed_addresses,  # ← ALL NONE (exploit trigger!)
        seed_script=seed_script,
        responses=responses,
        uids=uids,
        variation_count=variation_count,
        phonetic_similarity=phonetic_similarity,
        orthographic_similarity=orthographic_similarity,
        rule_based=rule_based
    )
    
    if detailed_metrics:
        metrics = detailed_metrics[0]
        address_grading = metrics.get('address_grading', {})
        address_score = address_grading.get('overall_score', 0.0)
        
        print(f"Address Score: {address_score:.3f}")
        print(f"Address grading keys: {list(address_grading.keys())}")
        
        if address_score == 1.0:
            print("✅ EXPLOIT WORKED with [None, None, ...]!")
        else:
            print(f"❌ Exploit failed: score = {address_score:.3f}")
        
except Exception as e:
    print(f"❌ Error: {e}")

# Test Case 3: All empty strings
print()
print("="*100)
print("TEST CASE 3: All empty strings ['', '', '', ...]")
print("="*100)
seed_addresses = [''] * len(seed_names)  # All empty strings - should trigger exploit

try:
    rewards, base_rewards, detailed_metrics = validator.get_name_variation_rewards(
        seed_names=seed_names,
        seed_dob=seed_dob,
        seed_addresses=seed_addresses,  # ← ALL EMPTY STRINGS (exploit trigger!)
        seed_script=seed_script,
        responses=responses,
        uids=uids,
        variation_count=variation_count,
        phonetic_similarity=phonetic_similarity,
        orthographic_similarity=orthographic_similarity,
        rule_based=rule_based
    )
    
    if detailed_metrics:
        metrics = detailed_metrics[0]
        address_grading = metrics.get('address_grading', {})
        address_score = address_grading.get('overall_score', 0.0)
        
        print(f"Address Score: {address_score:.3f}")
        print(f"Address grading keys: {list(address_grading.keys())}")
        
        if address_score == 1.0:
            print("✅ EXPLOIT WORKED with ['', '', ...]!")
        else:
            print(f"❌ Exploit failed: score = {address_score:.3f}")
        
except Exception as e:
    print(f"❌ Error: {e}")

# Test Case 4: Mix of None and empty strings
print()
print("="*100)
print("TEST CASE 4: Mix of None and empty strings [None, '', None, '', ...]")
print("="*100)
seed_addresses = [None, '', None, '', None]  # Mix - should trigger exploit

try:
    rewards, base_rewards, detailed_metrics = validator.get_name_variation_rewards(
        seed_names=seed_names,
        seed_dob=seed_dob,
        seed_addresses=seed_addresses,  # ← MIX OF NONE/EMPTY (exploit trigger!)
        seed_script=seed_script,
        responses=responses,
        uids=uids,
        variation_count=variation_count,
        phonetic_similarity=phonetic_similarity,
        orthographic_similarity=orthographic_similarity,
        rule_based=rule_based
    )
    
    if detailed_metrics:
        metrics = detailed_metrics[0]
        address_grading = metrics.get('address_grading', {})
        address_score = address_grading.get('overall_score', 0.0)
        
        print(f"Address Score: {address_score:.3f}")
        print(f"Address grading keys: {list(address_grading.keys())}")
        
        if address_score == 1.0:
            print("✅ EXPLOIT WORKED with mix of None/empty!")
        else:
            print(f"❌ Exploit failed: score = {address_score:.3f}")
        
except Exception as e:
    print(f"❌ Error: {e}")

print()
print("="*100)
print("EXPLOIT TEST COMPLETE")
print("="*100)
print()
print("Summary:")
print("- If Address Score = 1.0 and sub-scores are missing → Exploit works!")
print("- If Address Score = 0.0 → Exploit didn't work (normal validation)")
print()

